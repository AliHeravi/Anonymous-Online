package me.asycc.anonymousonline.client.network;

import me.asycc.anonymousonline.client.main.Client;
import me.asycc.anonymousonline.client.thread.PacketListeningThread;
import me.asycc.anonymousonline.client.thread.UpdateThread;
import me.asycc.anonymousonline.common.network.Packet;
import me.asycc.anonymousonline.common.network.impl.DisconnectPacket;
import me.asycc.anonymousonline.common.network.impl.HandshakePacket;
import me.asycc.anonymousonline.common.network.impl.RSAPacket;
import me.asycc.anonymousonline.common.network.impl.WelcomePacket;
import me.asycc.anonymousonline.common.utils.EncryptionUtils;
import me.asycc.anonymousonline.common.utils.SerializationUtils;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;

/**
 * A class to abstract {@link Socket} functions, as well as read for incoming bytes from the {@link Socket}
 * and pass them to the event handler
 *
 * @author Asyc
 * @since 3/5/2019
 */
public class Connection {

    /**
     * The socket connecting the server to send and receive data.
     */
    private Socket socket;

    /**
     * A thread used to listen for incoming packets without
     * blocking the main thread.
     */
    private Thread listeningThread;

    /**
     * A thread used for updating encryption keys.
     */
    private Thread updateThread;

    /**
     * A RSA key used for encryption; sent by the server.
     */
    private PublicKey publicKey;

    /**
     * A RSA key used for decryption; generated by the client.
     */
    private PrivateKey privateKey;

    /**
     * The amount of bytes to allocate to a {@link KeyPair} as well as
     * the amount of bytes to allocate to a byte array when reading from
     * the socket's input stream.
     */
    public final int size = 1024;



    /**
     *
     * Initializes {@link Connection#socket} and connects to a remote
     * server, as well as sending information about the client (nickname, version, etc).
     *
     * @param address The address of the server to connect to.
     * @param port The port of the server to connect to.
     */
    public void connect(final InetAddress address, final int port, final String nickname) throws IOException, GeneralSecurityException {
        this.socket = new Socket(address, port);
        final KeyPair pair = EncryptionUtils.generateKeyPair(size);
        this.privateKey = pair.getPrivate();

        this.send(new RSAPacket(pair.getPublic()));

        Packet packet = this.read();

        if(packet instanceof RSAPacket){
            this.publicKey = ((RSAPacket) packet).getKey();
        }

        this.send(new HandshakePacket(nickname, Client.instance.version));

        packet = this.read();

        if(packet instanceof DisconnectPacket){
            throw new IOException(((DisconnectPacket) packet).getReason());
        }

        this.listeningThread = new PacketListeningThread();
        this.updateThread = new UpdateThread();
        this.listeningThread.start();
        this.updateThread.start();
    }

    /**
     * Blocks the thread until an array of bytes is received from the client.
     * This method will proceed to un-encrypt the byte array, deserialize the byte array,
     * and cast it to a packet.
     *
     * @return Returns a packet read from the socket
     * @throws IOException If the socket could not be read from, or a
     * received packet could not be deserialized
     */
    public Packet read() throws IOException{
        byte[] allocated = new byte[size];
        final int result = socket.getInputStream().read(allocated);

        if(result == -1){
            //EOS has been reached, so disconnect.
            disconnect();
        }else if(result == 0){
            return null;
        }

        byte[] decrypted;

        try{
            decrypted = EncryptionUtils.decrypt(privateKey, allocated);
        }catch (GeneralSecurityException e){
            System.err.println("Unable to decrypt object, ignoring.");
            return null;
        }

        Packet received;

        try{
            received = (Packet) SerializationUtils.deserialize(decrypted);
        }catch (ClassNotFoundException | ClassCastException e){
            System.err.println("Client sent invalid packet, ignoring.");
            return null;
        }

        return received;
    }

    /**
     *
     * Serializes an {@link Packet} and encrypts the byte array to send through
     * the socket's {@link java.io.OutputStream}.
     *
     * @param packet The packet to send.
     *
     * @throws IOException Thrown if the {@link Packet} could not be serialized or the {@link Packet} could not be written to
     * the output stream.
     * @throws GeneralSecurityException Thrown if the serialized {@link Packet} could not be encrypted.
     */
    public void send(Packet packet) throws IOException, GeneralSecurityException{
        byte[] serialized = SerializationUtils.serialize(packet);
        byte[] encrypted = EncryptionUtils.encrypt(publicKey, serialized);

        socket.getOutputStream().write(encrypted);
    }

    /**
     * Disconnects the client from the server.
     */
    private void disconnect(){
        try{
            socket.close();
        }catch (IOException e){
            e.printStackTrace();
        }

        listeningThread.stop();
        updateThread.stop();
    }

    /**
     *
     * Generates a new {@link KeyPair} for encryption. Then sends a {@link RSAPacket} to the server.
     *
     * @throws IOException Thrown if the new {@link PublicKey} could not be sent through the socket.
     * @throws GeneralSecurityException Thrown if the byte array could not be encrypted
     * or the new {@link KeyPair} could not be generated.
     */
    public void updateKeys() throws IOException, GeneralSecurityException{
        KeyPair pair = EncryptionUtils.generateKeyPair(size);
        this.send(new RSAPacket(pair.getPublic()));
        this.privateKey = pair.getPrivate();
    }

    /**
     * @return Returns whether the socket is connected.
     */
    public boolean isConnected(){
        return socket.isConnected();
    }

    /**
     * A setter method.
     *
     * @param publicKey The {@link PublicKey} to change {@link Connection#publicKey} to.
     */
    public void setPublicKey(PublicKey publicKey) {
        this.publicKey = publicKey;
    }
}
