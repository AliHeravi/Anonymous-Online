package me.asycc.anonymousonline.server.network;

import me.asycc.anonymousonline.common.network.Packet;
import me.asycc.anonymousonline.common.network.impl.HandshakePacket;
import me.asycc.anonymousonline.common.network.impl.RSAPacket;
import me.asycc.anonymousonline.common.utils.EncryptionUtils;
import me.asycc.anonymousonline.common.utils.SerializationUtils;

import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;

/**
 *
 * A class to abstract {@link Socket} functions, as well as read for incoming bytes from the {@link Socket}
 * and pass them to the {@link me.asycc.anonymousonline.server.event.EventHandler}
 *
 * @author Asyc
 * @since 3/4/2019
 */
public class Client {

    /**
     * The client's socket used to send and receive data.
     */
    private Socket socket;

    /**
     * A RSA key used for encryption; sent by the client.
     */
    private PublicKey publicKey;

    /**
     * A RSA key used for decryption; generated by the server.
     */
    private PrivateKey privateKey;

    /**
     * The amount of bytes to allocate to a {@link KeyPair} as well as
     * the amount of bytes to allocate to a byte array when reading from
     * the socket's input stream.
     */
    private final int size = 1024;

    /**
     * The clients chosen nickname.
     */
    private String nickname;

    /**
     * @param socket The client's socket used for I/O
     */
    public Client(Socket socket){
        this.socket = socket;

        try {
            Packet packet = this.read();

            if(packet instanceof RSAPacket){
                this.publicKey = ((RSAPacket) packet).getKey();
                KeyPair pair = EncryptionUtils.generateKeyPair(size);
                this.privateKey = pair.getPrivate();
                this.send(new RSAPacket(pair.getPublic()));
            }

            packet = this.read();

            if(packet instanceof HandshakePacket){



                this.nickname = ((HandshakePacket) packet).getNickname();
            }

        }catch (IOException e){
            System.err.println("Could not read from client, disconnecting.");
            disconnect();
            return;
        }catch (GeneralSecurityException e){
            System.err.println("Could not generate encryption keypair, disconnecting.");
            disconnect();
            return;
        }

        //todo : stuff
    }

    /**
     *
     * Blocks the thread until an array of bytes is received from the client.
     * This method will proceed to un-encrypt the byte array, deserialize the byte array,
     * and cast it to a packet.
     *
     * @return Returns a packet read from the socket
     * @throws IOException If the socket could not be read from, or a
     * received packet could not be deserialized
     */
    public Packet read() throws IOException {
        byte[] readBytes = new byte[size];
        int result = socket.getInputStream().read(readBytes);

        if(result == 0){
            return null;
        }else if(result == -1){
            //EOS has been reached, so disconnect.
            disconnect();
        }

        byte[] bytes;

        try {
            bytes = EncryptionUtils.decrypt(privateKey, readBytes);
        }catch (GeneralSecurityException e){
            System.err.println("Unable to decrypt packet. Ignoring.");
            return null;
        }

        Packet packet;

        try{
            packet = (Packet) SerializationUtils.deserialize(bytes);
        }catch (ClassCastException | ClassNotFoundException e){
            System.err.println("Client sent invalid packet, ignoring.");
            return null;
        }

        return packet;
    }

    /**
     *
     * Serializes an {@link Packet} and encrypts the byte array to send through
     * the socket's {@link java.io.OutputStream}.
     *
     * @param packet The packet to send.
     *
     * @throws IOException Thrown if the {@link Packet} could not be serialized or the {@link Packet} could not be written to
     * the output stream.
     * @throws GeneralSecurityException Thrown if the serialized {@link Packet} could not be encrypted.
     */
    public void send(Packet packet) throws IOException, GeneralSecurityException{
        byte[] serialized = SerializationUtils.serialize(packet);
        byte[] encrypted = EncryptionUtils.encrypt(publicKey, serialized);

        socket.getOutputStream().write(encrypted);
    }

    /**
     * Closes the {@link Socket} connection between the server and the client and sending a disconnect packet.
     */
    private void disconnect(){
        try{
            socket.close();
        }catch (IOException e){
            System.err.println("Could not close client socket. " + e.getMessage());
        }
    }
}
